---
permalink: /:categories/:year/:month/:title.html
layout: post
title: Using Apache Camel and CDI for creating scalable distributed services backed
  by JMS (part 2)
date: '2015-10-25T16:46:00.001-07:00'
author: Andres Olarte
tags:
- integration
- messaging
- jms
- dependency injection
- cdi
- camel
- java
modified_time: '2016-05-31T17:02:27.888-07:00'
thumbnail: http://4.bp.blogspot.com/-cAkq9jncT6c/Vi0KV503a9I/AAAAAAAAHHc/F2v5CnzIFXI/s72-c/camel-box-small.png
blogger_id: tag:blogger.com,1999:blog-3306197464901287625.post-5523967251946346988
blogger_orig_url: http://www.javaprocess.com/2015/10/distributed-services-with-apache-camel-part2.html
---

<div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-cAkq9jncT6c/Vi0KV503a9I/AAAAAAAAHHc/F2v5CnzIFXI/s1600/camel-box-small.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" src="http://4.bp.blogspot.com/-cAkq9jncT6c/Vi0KV503a9I/AAAAAAAAHHc/F2v5CnzIFXI/s1600/camel-box-small.png" /></a></div>Continuing the example shown in <a href="http://www.javaprocess.com/2015/10/distributed-services-with-apache-camel-part1.html">part1</a>&nbsp;we now add a new feature, the <a href="http://www.enterpriseintegrationpatterns.com/patterns/messaging/StoreInLibrary.html">Claim Check</a>. This is the Apache Camel / CDI equivalent of another <a href="http://www.javaprocess.com/2015/06/spring-integration-services-part2.html">Spring Integration example</a> shown before. &nbsp;This pattern, along with most of the groundwork used in enterprise integration, was first codified in "Enterprise Integration Patterns" by<br />Gregor Hohpe and Bobby Woolf. This book is a must read for any one working in this area, regardless of the tool.<br /><br /><div class="separator" style="clear: both; text-align: center;"></div>In this example we add the necessary pieces to store data in an external data store while our original message is route throughout our system. The main motivation is to avoid sending and receiving large amounts of data through JMS or other similar systems that are designed to handle low latency communication. Contrary to Spring Integration, Apache Camel does not offer an out of the box implementation of the the Claim Check pattern. The pattern and how to implemented are described&nbsp;<a href="http://camel.apache.org/claim-check.html">here</a>.There are talks of introducing one for Apache Camel 3.0, but reading the discussions it becomes evident that providing a flexible general case implementation is complicated. Spring Integration provides an implementation, but many times it's insufficient, as it becomes evident that it's necessary to only store parts of the message (most likely binary portions of the message), while keeping most of the message to be processed along the pipeline. The general flow of this pattern can be seen below:<br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-Apw2c4hQui8/VYD8JIKmyNI/AAAAAAAAF-Y/6Wr3BZ3Zvs0/s1600/StoreInLibrary.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-Apw2c4hQui8/VYD8JIKmyNI/AAAAAAAAF-Y/6Wr3BZ3Zvs0/s1600/StoreInLibrary.gif" /></a></div><h3>The code</h3>To implement the Claim Check pattern, five different new classes were created. The first two classes provide the actual implementation of the two pieces that make up the Claim Check pattern. The two pieces are in essence a <a href="http://www.enterpriseintegrationpatterns.com/patterns/messaging/ContentFilter.html">Content Filter</a> that removes part of the content (and stores it in separate database), and a <a href="http://www.enterpriseintegrationpatterns.com/patterns/messaging/DataEnricher.html">Content Enricher</a> that will pull the data from database and back into the message. The code is seen below:<br /><br /><pre class="brush: java">@Named("claimCheckIn")<br />public class ClaimCheckIn {<br /><br />    @Inject<br />    private DataStore dataStore;<br /><br />    public void checkIn(Exchange exchange, @Body Object body) {<br />        String id = UUID.randomUUID().toString();<br />        // store the message in the data store<br />        dataStore.put(id, body);<br />        // add the claim check as a header<br />        exchange.getIn().setHeader("claimCheck", id);<br />        // remove the body from the message<br />        exchange.getIn().setBody(null);<br />    }<br />}<br /></pre><br /><pre class="brush: java">@Named("claimCheckOut")<br />public class ClaimCheckOut {<br /><br />    @Inject<br />    private DataStore dataStore;<br /><br />    public void checkOut(Exchange exchange, @Header("claimCheck") String claimCheck) {<br />        exchange.getIn().setBody(dataStore.get(claimCheck));<br />        // remove the message data from the data store<br />        dataStore.remove(claimCheck);<br />        // remove the claim check header<br />        exchange.getIn().removeHeader("claimCheck");<br />    }<br />}<br /></pre><br /><br />The data store provides a very simple abstraction to put, get, and delete objects from the database. This current implementation is using JDBC, but shows the basics of how a data store can be implemented:<br /><pre class="brush: java" >public class DataStore {<br /><br />    @Inject<br />    DataSource dataSource;<br /><br />    public void put(String id, Object body) {<br />        try (Connection connection = dataSource.getConnection();<br />             PreparedStatement stmt = connection.prepareCall("INSERT INTO DATA (id,data) VALUES (?,?)")) {<br />            stmt.setString(1, id);<br />            stmt.setObject(2, body);<br />            stmt.executeUpdate();<br />        } catch (SQLException e) {<br />            e.printStackTrace();<br />        }<br />    }<br /><br />    public Object get(String id) {<br />        Object ret = null;<br />        try (Connection connection = dataSource.getConnection();<br />             PreparedStatement stmt = connection.prepareCall("SELECT * FROM  DATA WHERE id=?")) {<br />            stmt.setString(1, id);<br />            try (ResultSet rs = stmt.executeQuery()) {<br />                if (rs.next()) {<br />                    ret = rs.getObject("data");<br />                }<br />            }<br /><br />        } catch (SQLException e) {<br />            e.printStackTrace();<br />        }<br />        return ret;<br />    }<br /><br />    public void remove(String id) {<br />        try (Connection connection = dataSource.getConnection();<br />             PreparedStatement stmt = connection.prepareCall("DELETE FROM  DATA WHERE id=?")) {<br />            stmt.setString(1, id);<br />            stmt.executeUpdate();<br />        } catch (SQLException e) {<br />            e.printStackTrace();<br />        }<br />    }<br />}<br /><br /></pre><br /><br />The last two new classes, H2ServerWrapper and DataSourceProvider, provide the connections to the database, as well as starting the in memory H2 database. Theses classes are normally not needed, since connections are handled by the application server in most Java EE applications. &nbsp;There were added here to provide similar functionality without an application server. You're welcome to look at the code, but in future post I'll explain in more detail how to provide these services from inside CDI.<br /><br /><h3>Wiring it all together</h3>Once we have our classes implementing the functionality, the wiring is very simple:<br /><pre class="brush: java">    RouteBuilder jmsClientCamelRoute = new RouteBuilder() {<br />        @Override<br />        public void configure() throws Exception {<br />            from("direct:order").to("jms:queue:order", "bean:claimCheckOut").setExchangePattern(ExchangePattern.InOut);<br />        }<br />    };<br /><br />    RouteBuilder jmsServerCamelRoute = new RouteBuilder() {<br />        @Override<br />        public void configure() throws Exception {<br />            from("jms:queue:order?concurrentConsumers=5").to("bean:orderServiceHandler", "bean:claimCheckIn");<br />        }<br />    };<br /></pre><br />All it takes is adding one destination before and one after. &nbsp;In Camel, declaring multiple destinations will create a pipeline. This means that the message will be sent to the first destination, then the result of the first destination will be sent to the second destination, and so on. This in contrast to multicast, which will send the same message to all of the destinations.<br /><br />The first change is the addition of &nbsp;"bean:claimCheckOut", after "jms:queue:order". What this does is to check out the data and putting it back on the message once the response arrives. &nbsp;Something similar is done on the server side. &nbsp;First we process the request using the orderServiceHandler bean, and then put the response in the data store. &nbsp;This particular configuration is using the check in for only the response.<br /><br />It's fairly easy to change it to use the claim check for both the request and the response. It's worth noting that such cases are not common in practice, as normally either the response or the request are large.<br /><pre class="brush: java">    RouteBuilder jmsClientCamelRoute = new RouteBuilder() {<br />        @Override<br />        public void configure() throws Exception {<br />            from("direct:order").to("bean:claimCheckIn", "jms:queue:order", "bean:claimCheckOut").setExchangePattern(ExchangePattern.InOut);<br />        }<br />    };<br /><br />    RouteBuilder jmsServerCamelRoute = new RouteBuilder() {<br />        @Override<br />        public void configure() throws Exception {<br />            from("jms:queue:order?concurrentConsumers=5").to("bean:claimCheckOut", "bean:orderServiceHandler", "bean:claimCheckIn");<br />        }<br />    };<br /></pre>In this case, request is also stored. &nbsp;Since our check in method stores the whole object, this will an instance of <a href="https://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/component/bean/BeanInvocation.html">BeanInvokation</a>. This method contains the parameters and other information need to invoke the service method. &nbsp;Based on your needs, you could of course only extract part of this object, for example one or more of the parameters, while keeping the rest of the message intact. <br /><br /><h3>Side by side comparison with Spring Integration</h3><div><div>The following sections compare mostly equivalent Spring Integration XML to their Apache Camel DSL. I have not included the implementation of the extra infrastructure pieces which Apache Camel requires.<br /><br /></div></div><b>Routing to a JMS queue and then retrieing the data from the data store</b><br /><pre class="brush: xml">&lt;int:chain input-channel="requestChannel"&gt;<br />    &lt;int-jms:outbound-gateway request-destination="amq.outbound" extract-request-payload="true"/&gt;<br />    &lt;int:claim-check-out message-store="clientMessageStore"/&gt;<br />&lt;/int:chain&gt;<br /></pre><b>vs</b><br /><pre class="brush: java">from("direct:order").to( "jms:queue:order", "bean:claimCheckOut").setExchangePattern(ExchangePattern.InOut);<br /></pre><br /><b>Listening to a JMS queue and routing messages to a bean and storing the result</b><br /><br /><pre class="brush: xml">&lt;int:chain  input-channel="inChannel"&gt; <br />    &lt;int:service-activator ref="orderServiceHandler" method="processOrder"/&gt;<br />    &lt;int:claim-check-in message-store="serverMessageStore"/&gt; <br />&lt;/int:chain&gt;<br /></pre><b>vs</b><br /><pre class="brush: java"><br />from("jms:queue:order?concurrentConsumers=5").to( "bean:orderServiceHandler", "bean:claimCheckIn");<br /></pre><h3>Conclusion</h3> From this short tutorial, it's evident that Apache Camel requires quite a bit extra code to accomplish the same tasks we did with Spring Integration. However, most of it becomes irrelevant if running inside an application server, which is the main target for CDI. &nbsp;The biggest piece that I feel should be provided by Apache Camel is a set of data stores using common data sources such as JDBC, JPA, and some of the more popular NoSQL databases. &nbsp;However, once that hurdle is overcome, Apache Camel shines in the ease in which complex problems can be solved in clear concise and easy to maintain code. So which one is better? A lot of it depends on what framework you're already using (Spring vs CDI), and if any of the integration platforms provides a particular esoteric feature. But in the end, both tools are very capable and easy to use.<br /><br /><h3>Source code</h3>You can find the source code for this example in github.<br />To check out the code clone the following repository:https://github.com/aolarte/camel-integration-samples.git.<br /><pre class="brush: bash"><br />git clone https://github.com/aolarte/camel-integration-samples.git<br />git checkout branches/part2<br /></pre>This example can be run directly from maven. For example : <pre class="brush: bash">mvn exec:java -Dexec.mainClass="com.javaprocess.examples.integration.main.Main" -Dexec.args="server client"</pre>