---
permalink: /:categories/:year/:month/:title.html
layout: post
title: Using Spring Integration for creating scalable distributed services backed
  by JMS (part 2)
date: '2015-06-17T16:49:00.002-07:00'
author: Andres Olarte
tags:
- integration
- jdbc
- jms
- esb
- spring
- h2
- spring-integration
- java
modified_time: '2016-05-31T17:02:27.885-07:00'
thumbnail: http://1.bp.blogspot.com/-PSlpvpgeB6Y/VYD9-AKK9BI/AAAAAAAAF-o/0MruKGTHgTA/s72-c/StoreInLibrary.gif
blogger_id: tag:blogger.com,1999:blog-3306197464901287625.post-3274111061827674944
blogger_orig_url: http://www.javaprocess.com/2015/06/spring-integration-services-part2.html
---

In <a href="http://www.javaprocess.com/2015/05/spring-integration-services-part1.html">part 1</a> of this series, we explored how Spring Integration allows us to easily leverage some of the Enterprise Integration Patterns to deploy salable services. In this part we'll take a look at one more pattern that is very helpful, the <a href="http://www.enterpriseintegrationpatterns.com/StoreInLibrary.html">claim check pattern</a>. This patterns allows to store parts of message, to be retrieved at a later stage. &nbsp;This is illustrated on the following diagram:<br /><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-PSlpvpgeB6Y/VYD9-AKK9BI/AAAAAAAAF-o/0MruKGTHgTA/s1600/StoreInLibrary.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-PSlpvpgeB6Y/VYD9-AKK9BI/AAAAAAAAF-o/0MruKGTHgTA/s1600/StoreInLibrary.gif" /></a></div><br />In practice, this pattern allows us to avoid having to send very large messages across the JMS broker. Message brokers are designed to handle many small messages, and performance tends to degrade with larger messages. While there are ways of tweaking the different JMS brokers to work better in these kinds of workloads, the "Claim Check" pattern allows us to sidestep the issue entirely, by using a separate storage mechanism to hold parts of our messages. So how big is too big for a message? That's a very subjective matter, but good common sense will tell us that for example most large binary data should not be transferred through a JMS broker. <br />Luckily Spring Integration provides out of the box support for this pattern. &nbsp;In fact, we can use the pattern without making any changes to our code. We do require some extra libraries, which we have added to the pom.xml file: <br /><pre class="brush: xml">&lt;dependency&gt;<br />    &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;<br />    &lt;artifactId&gt;spring-integration-jdbc&lt;/artifactId&gt;<br />    &lt;version&gt;${spring.version}&lt;/version&gt;<br />&lt;/dependency&gt;<br /><br />&lt;dependency&gt;<br />    &lt;groupId&gt;com.h2database&lt;/groupId&gt;<br />    &lt;artifactId&gt;h2&lt;/artifactId&gt;<br />    &lt;version&gt;1.4.187&lt;/version&gt;<br />&lt;/dependency&gt;<br /><br />&lt;dependency&gt;<br />    &lt;groupId&gt;commons-dbcp&lt;/groupId&gt;<br />    &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;<br />    &lt;version&gt;1.4&lt;/version&gt;<br />&lt;/dependency&gt;<br /></pre>We have added: <br /><br /><ol><li>The Spring Integration JDBC jar. This provides, among other functionality, a JDBC backed message store.</li><li>H2, a Java embedded database. In this database we will store our messages.</li><li>Apache Commons DBCP, a connection pool to manage our JDBC connections.</li></ol><br />Now let's look at the spring-int-server.xml file: <br /><pre class="brush: java">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:jdbc="http://www.springframework.org/schema/jdbc"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:int="http://www.springframework.org/schema/integration"<br />       xmlns:int-jms="http://www.springframework.org/schema/integration/jms"<br />       xmlns:int-jdbc="http://www.springframework.org/schema/integration/jdbc"<br />       xmlns:amq="http://activemq.apache.org/schema/core"<br />       xsi:schemaLocation="<br />   http://www.springframework.org/schema/beans<br />   http://www.springframework.org/schema/beans/spring-beans.xsd<br />   http://www.springframework.org/schema/jdbc<br />   http://www.springframework.org/schema/jdbc/spring-jdbc.xsd<br />   http://www.springframework.org/schema/integration<br />   http://www.springframework.org/schema/integration/spring-integration.xsd<br />   http://www.springframework.org/schema/integration/jms<br />   http://www.springframework.org/schema/integration/jms/spring-integration-jms.xsd<br />   http://www.springframework.org/schema/integration/jdbc<br />   http://www.springframework.org/schema/integration/jdbc/spring-integration-jdbc.xsd<br />   http://activemq.apache.org/schema/core<br />   http://activemq.apache.org/schema/core/activemq-core.xsd<br />  "&gt;<br /><br /><br />    &lt;amq:broker id="activeMQBroker" useJmx="false" persistent="false"&gt;<br />        &lt;amq:transportConnectors&gt;<br />        &lt;amq:transportConnector uri="tcp://localhost:61616" /&gt;<br />        &lt;/amq:transportConnectors&gt;<br />    &lt;/amq:broker&gt;<br /><br />    &lt;bean id="h2DBServer" class="org.h2.tools.Server" &lt;!-- 1 --&gt;<br />          factory-method="createTcpServer" init-method="start" destroy-method="stop"&gt;<br />        &lt;constructor-arg value="-tcp,-tcpAllowOthers,-tcpPort,8043" /&gt;<br />    &lt;/bean&gt;<br /><br /><br />    &lt;bean id="serverDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;!-- 2 --&gt;<br />        &lt;property name="driverClassName" value="org.h2.Driver"/&gt;<br />        &lt;property name="url" value="jdbc:h2:tcp://localhost:8043/mem:test"/&gt;<br />        &lt;property name="username" value="sa"/&gt;<br />        &lt;property name="password" value=""/&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;jdbc:initialize-database data-source="serverDataSource"&gt; &lt;!-- 3 --&gt;<br />        &lt;jdbc:script location="classpath:org/springframework/integration/jdbc/schema-h2.sql"/&gt;<br />    &lt;/jdbc:initialize-database&gt;<br /><br />    &lt;int-jdbc:message-store id="serverMessageStore" data-source="serverDataSource"/&gt; &lt;!-- 4 --&gt;<br /><br />    &lt;bean id="orderServiceHandler" class="com.javaprocess.examples.integration.impl.OrderServiceHandler"/&gt;<br /><br />    &lt;int:channel id="inChannel" /&gt;<br /><br />    &lt;int-jms:inbound-gateway request-channel="inChannel"<br />                             request-destination="amq.outbound"<br />                             concurrent-consumers="10"/&gt;<br />    &lt;int:chain  input-channel="inChannel"&gt; &lt;!-- 5 --&gt;<br />        &lt;int:service-activator ref="orderServiceHandler" method="processOrder"/&gt;<br />        &lt;int:claim-check-in message-store="serverMessageStore"/&gt; &lt;!-- 6 --&gt;<br />    &lt;/int:chain&gt;<br /><br /><br />&lt;/beans&gt;<br /></pre>Now let's look at the changes: <br /><ol><li>We have an in memory instance of an H2 database. H2 is a very useful embedded database, which means that we can run it inside of our JVM process. No need to have a separate database server for this example. Both the server and the client will connect to this instance. Obviously in production you will choose something more robust. But for this example, this setup works well. It's worth noting that the H2 is started with the configuration options needed to accept outside connections over TCP.</li><li>A datasource is created. This datasource will point to the database server created in point #1.</li><li>A data base initialization element. Spring Integration requires some tables to be created in the database that will be used as a message store. Since our database will reside in memory, this will be run every time the server is started up.</li><li>The message store we're using is a JDBC store, using the data source defined in #2.</li><li>We now introduce the chain element. The chain element allows multiple filter or transformations to be chained together. In this case we're still delegating to the orderServiceHandler bean for processing as the first step in the chain.</li><li>In the second step of the chain, we check in the message. This transformed will take the message (which must be serializable ), store in the message store, and return a UUID (Universally Unique Identifier). This UUID is sent to the client.</li></ol>Now let's look at the client side. The client side is very similar to server (actually a bit simpler). <br /><pre class="brush: java">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:int="http://www.springframework.org/schema/integration"<br />       xmlns:int-jms="http://www.springframework.org/schema/integration/jms"<br />       xmlns:int-jdbc="http://www.springframework.org/schema/integration/jdbc"<br />       xsi:schemaLocation="<br />   http://www.springframework.org/schema/beans<br />   http://www.springframework.org/schema/beans/spring-beans.xsd<br />   http://www.springframework.org/schema/integration<br />   http://www.springframework.org/schema/integration/spring-integration.xsd<br />   http://www.springframework.org/schema/integration/jms<br />   http://www.springframework.org/schema/integration/jms/spring-integration-jms.xsd<br />   http://www.springframework.org/schema/integration/jdbc<br />   http://www.springframework.org/schema/integration/jdbc/spring-integration-jdbc.xsd<br />  "&gt;<br /><br />    &lt;int:channel id="requestChannel"/&gt;<br /><br />    &lt;bean id="clientDataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close"&gt; &lt;!-- 1 --&gt;<br />        &lt;property name="driverClassName" value="org.h2.Driver"/&gt;<br />        &lt;property name="url" value="jdbc:h2:tcp://localhost:8043/mem:test"/&gt;<br />        &lt;property name="username" value="sa"/&gt;<br />        &lt;property name="password" value=""/&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;int-jdbc:message-store id="clientMessageStore" data-source="clientDataSource" /&gt; &lt;!-- 2 --&gt;<br /><br />    &lt;int:gateway id="orderService"<br />                 service-interface="com.javaprocess.examples.integration.interfaces.IOrderService"<br />                 default-request-channel="requestChannel"/&gt;<br />    &lt;int:chain input-channel="requestChannel"&gt; &lt;!-- 3 --&gt;<br />        &lt;int-jms:outbound-gateway request-destination="amq.outbound" extract-request-payload="true"/&gt;<br />        &lt;int:claim-check-out message-store="clientMessageStore"/&gt;<br />    &lt;/int:chain&gt;<br /><br /><br /><br />    &lt;bean id="app" class="com.javaprocess.examples.integration.impl.App"&gt;<br />        &lt;property name="orderService" ref="orderService"/&gt;<br />    &lt;/bean&gt;<br /><br />&lt;/beans&gt;<br /></pre>Let's look at the changes in this file: <br /><br /><ol><li>A data source is created, using the same URL as in the server side. There's no need to start up the H2 server here, since we're using the H2 running inside the server process.</li><li>A message store is created using the data source created in #1.</li><li>A chain is created to handle messages in the "requestChannel". This chain will receive a UUID, and retrieve the corresponding object from the message store.</li></ol><div>To check out the code clone the following repository:&nbsp;https://github.com/aolarte/spring-integration-samples.git.</div><pre class="brush: java">git clone https://github.com/aolarte/spring-integration-samples.git<br />git checkout branches/part2<br /></pre>Once you checkout the code, you can run the server and client process using Maven (in different terminals): <br /><pre class="brush: java">mvn exec:java -Dexec.mainClass="com.javaprocess.examples.integration.main.Main" -Dexec.args="server"</pre><br /><pre class="brush: java">mvn exec:java -Dexec.mainClass="com.javaprocess.examples.integration.main.Main" -Dexec.args="client"</pre><br />You will see the exact same output as in part 1. While that might seem anti-climatic, the important aspect is what is happening behind the scenes. The message is being stored in a database, and a UUID is sent across the wire. &nbsp;What we have implemented is a very simple Enterprise Service Bus. &nbsp;There's plenty of opportunities to use patterns like this. On the next article we will elaborate on some of these opportunities.