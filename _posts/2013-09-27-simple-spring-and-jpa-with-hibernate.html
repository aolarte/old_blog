---
permalink: /:categories/:year/:month/:title.html
layout: post
title: 'Simple Spring and JPA with Hibernate tutorial. Part 1: The basics'
date: '2013-09-27T13:04:00.000-07:00'
author: Andres Olarte
tags:
- spring-mvc
- jpa
- hibernate
- spring
- java
modified_time: '2013-10-09T12:09:23.729-07:00'
thumbnail: http://3.bp.blogspot.com/-zsLSlOVOsgg/UkXgeGW_EbI/AAAAAAAAALs/k1vLgdG7_Vo/s72-c/sc1.png
blogger_id: tag:blogger.com,1999:blog-3306197464901287625.post-7331955557819329436
blogger_orig_url: http://www.javaprocess.com/2013/09/simple-spring-and-jpa-with-hibernate.html
---

This is a very basic Spring application, using MVC for the web interface and JPA for persistence.  As the JPA implementation we will use Hibernate.  However, it is fairly easy to switch to another JPA implementation such as EclipseLink (we will look at how to do this in a later post).  In as much as possible, this example uses convention over configuration, favoring brevity over exhaustive listing of options.  <br />This example requires Maven to be installed and functional.  I'm using version 3.0.4, but any relatively new version should suffice.  <br />We'll start taking a look at the pom.xml: <br /><p><b>pom.xml</b></p><pre class="brush: xml">&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;<br />    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br />    &lt;groupId&gt;test.tutorials&lt;/groupId&gt;<br />    &lt;artifactId&gt;spring-hib-jpa&lt;/artifactId&gt;<br />    &lt;packaging&gt;war&lt;/packaging&gt;<br />    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;<br />    &lt;name&gt;spring-hib-jpa Maven Webapp&lt;/name&gt;<br /><br /><br />    &lt;properties&gt;   &lt;!-- 1 --&gt;<br />        &lt;springVersion&gt;3.2.4.RELEASE&lt;/springVersion&gt;<br />    &lt;/properties&gt;<br /><br />    &lt;dependencies&gt;<br /><br />        &lt;dependency&gt;    &lt;!-- 2 --&gt;<br />            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;<br />            &lt;version&gt;${springVersion}&lt;/version&gt;<br />        &lt;/dependency&gt;<br /><br />        &lt;dependency&gt;    &lt;!-- 3 --&gt;<br />            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;<br />            &lt;version&gt;${springVersion}&lt;/version&gt;<br />        &lt;/dependency&gt;<br /><br />        &lt;dependency&gt;    &lt;!-- 4 --&gt;<br />            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br />            &lt;artifactId&gt;spring-orm&lt;/artifactId&gt;<br />            &lt;version&gt;${springVersion}&lt;/version&gt;<br />        &lt;/dependency&gt;<br /><br />        &lt;dependency&gt;    &lt;!-- 5 --&gt;<br />            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;<br />            &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;<br />            &lt;version&gt;4.1.9.Final&lt;/version&gt;<br />        &lt;/dependency&gt;<br /><br />        &lt;dependency&gt;    &lt;!-- 6 --&gt;<br />            &lt;groupId&gt;jstl&lt;/groupId&gt;<br />            &lt;artifactId&gt;jstl&lt;/artifactId&gt;<br />            &lt;version&gt;1.2&lt;/version&gt;<br />        &lt;/dependency&gt;<br /><br />        &lt;dependency&gt;    &lt;!-- 7 --&gt;<br />            &lt;groupId&gt;com.h2database&lt;/groupId&gt;<br />            &lt;artifactId&gt;h2&lt;/artifactId&gt;<br />            &lt;version&gt;1.3.161&lt;/version&gt;<br />        &lt;/dependency&gt;<br /><br />        &lt;dependency&gt;    &lt;!-- 8 --&gt;<br />            &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;<br />            &lt;artifactId&gt;tomcat-dbcp&lt;/artifactId&gt;<br />            &lt;version&gt;7.0.41&lt;/version&gt;<br />        &lt;/dependency&gt;<br /><br />    &lt;/dependencies&gt;<br />&lt;/project&gt;<br /></pre>See below for detailed explanation of this file   <br /><ol><li>We define the Spring version as a property, since we'll reuse this property for several dependencies.  You could do the same thing for the other libraries we're importing, but after a point, it becomes overkill.  As of the writing of this tutorial, the latest stable Spring 3 is 3.2.4.RELEASE.</li><li>The spring-beans package includes the basics to configure spring, and will be required in basically all spring applications.</li><li>The spring-webmvc package provides front end functionality, which we'll use to create our UI.</li><li>The spring-orm package provides the infrastructure to map Object Relational Mapping (ORM) tools into Spring.  Nowadays most new work is done using JPA (Java Persistence Architecture) interfaces.  This module provides the glue logic between the ORMimplementation and your application, exposing standard JPA interfaces, while still allowing to take advantage of specialized features provided by the ORM framework of your choosing.</li><li>The hibernate-entitymanager provides the Hibernate implementation, to do our database work behind the scenes.</li><li>The JSTL api will provide us with some standard tools to make writing our JSPs a bit easier.</li><li>In this simple example will use an embedded database, H2.  This database will run within the Java process, so we can do our work without the need to have an external database server.  ORM implementations allow you to move between a small embedded database an a big "enterprise" level database without big changes to your code.</li><li>A database connection pool improves performance by keeping a pool of open connections that clients can use.  In most J2EE applications the database connection pool is managed by the application server (Tomcat, Weblogic, JBoss, Glassfish, etc... ).  For this example we'll provide our own connection pool.</li></ol>Now let's look at the web.xml: <br /><p><b>src/main/webapp/WEB-INF/web.xml</b></p><pre class="brush: xml">&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" version="2.5"&gt;<br /><br />    &lt;servlet&gt;<br />      &lt;servlet-name&gt;spring&lt;/servlet-name&gt;<br />      &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;<br />      &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;<br />    &lt;/servlet&gt;<br />   <br />    &lt;servlet-mapping&gt;<br />        &lt;servlet-name&gt;spring&lt;/servlet-name&gt;<br />        &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;<br />    &lt;/servlet-mapping&gt;<br /><br />&lt;/web-app&gt;<br /></pre>The web.xml is simple enough, with a single Servlet, provided by Spring, and a single mapping, which will send requests ending in html to the Spring MVC servlet.  Loading of the DispatcherServlet will trigger Spring to look for a configuration file named spring-servlet.xml.  This is based on the servlet name and the "-servlet.xml" postfix.  There are other ways of configuring Spring, but for now the spring-servlet.xml file will suffice: <br /><p><b>src/main/webapp/WEB-INF/spring-servlet.xml</b></p> <pre class="brush: xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br />&lt;beans xmlns="http://www.springframework.org/schema/beans"<br />       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"<br />       xmlns:tx="http://www.springframework.org/schema/tx"<br />       xmlns:context="http://www.springframework.org/schema/context"<br />       xmlns:mvc="http://www.springframework.org/schema/mvc"<br />       xsi:schemaLocation="http://www.springframework.org/schema/beans<br />        http://www.springframework.org/schema/beans/spring-beans.xsd<br />        http://www.springframework.org/schema/context<br />        http://www.springframework.org/schema/context/spring-context.xsd<br />        http://www.springframework.org/schema/tx<br />        http://www.springframework.org/schema/tx/spring-tx.xsd<br />        http://www.springframework.org/schema/mvc<br />        http://www.springframework.org/schema/mvc/spring-mvc.xsd<br />        "&gt;<br /><br />    &lt;context:component-scan base-package="test"/&gt;  &lt;!-- 1 --&gt;<br />    &lt;mvc:annotation-driven/&gt;  &lt;!-- 2 --&gt;<br />    &lt;tx:annotation-driven/&gt;  &lt;!-- 3 --&gt;<br /><br />    &lt;bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 4 --&gt;<br />        &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt;<br />        &lt;property name="suffix" value=".jsp"/&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="dataSource" class="org.apache.tomcat.dbcp.dbcp.BasicDataSource"&gt;  &lt;!-- 5 --&gt;<br />        &lt;property name="driverClassName" value="org.h2.Driver"/&gt;<br />        &lt;property name="url" value="jdbc:h2:mem:test"/&gt;<br />    &lt;/bean&gt;<br /><br /><br />    &lt;bean id="entityManagerFactory"<br />          class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;  &lt;!-- 6 --&gt;<br />        &lt;property name="dataSource" ref="dataSource"/&gt;<br />        &lt;property name="packagesToScan" value="test.model"/&gt;<br />        &lt;property name="jpaVendorAdapter"&gt;  &lt;!-- 7 --&gt;<br />            &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"&gt;<br />            &lt;/bean&gt;<br />        &lt;/property&gt;<br />        &lt;property name="jpaProperties"&gt;  &lt;!-- 8 --&gt;<br />            &lt;props&gt;<br />                &lt;prop key="hibernate.show_sql"&gt;true&lt;/prop&gt;<br />                &lt;prop key="hibernate.dialect"&gt;org.hibernate.dialect.H2Dialect&lt;/prop&gt;<br />                &lt;prop key="hibernate.hbm2ddl.auto"&gt;create-drop&lt;/prop&gt;<br />            &lt;/props&gt;<br />        &lt;/property&gt;<br />    &lt;/bean&gt;<br /><br />    &lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"/&gt;  &lt;!-- 9 --&gt;<br /><br />&lt;/beans&gt;<br /></pre><ol><li>Component scan from the context namespace will crawl through the source tree starting at package "test" and will wire all annotated objects.  It will discover and wire any beans with the annotations @Controller, @Service, @Component, and @Repository.  This will also enable configuration based annotation, which would normally be done with "&lt;context:annotation-config/&gt;".</li><li>MVC is the user interface framework we'll use, and mvc:annotation-driven wires http actions from beans that have @RequestMapping annotations.  In the MVC (Model View Controller) pattern, these beans are the Controllers.</li><li>The tx namespace allows configuring Spring's transaction support.  The element tx:annotation-driven instructs Spring to apply transaction functionality to beans that have @Transactional annotations.  Spring will inject a transaction manager into the proper beans.  By convention, a transaction manager name "transactionManager" will be injected, but can by configured explicitly by adding transaction-manager="nameOfMyTransactionManagerBean" to the tx:annotation-driven element.  In this case we're defining trasactionManager further down the configuration file.</li><li>The viewResolver allows Spring MVC to locate the JSPs that represent the View in the MVC pattern.  In this case we'll keep the JSPs in the /WEB-INF/jsp/ directory, so that they cannot be hit directly, but accessed only through the controllers.</li><li>In this example, we're providing the data source (instead of finding a data source provided by an application server).  The properties passed must include at least the driver corresponding to the database to use, and a url.  Since we are using an embedded database, nothing else is required, but most other databases will also require a username and password to be passed in as well.</li><li>The entity manager factory provides access to the JPA implementation.  In this case we're using the adapter that allows using Hibernate.  The factory requires several attributes to be passed in.  In particular a dataSource (in this case referencing the one created in point #5) and and package to scan for JPA entity classes.  In this case we're scanning the test.model package for classes annotated with @Entity.</li><li>The jpaVendorAdapter property takes a class implementing JpaVendorAdapter.  In this case we provide the one appropriate for hibernate.  Inside this property we further configure the adapter, however the syntax is more limited than what can be done passing properties directly as we do here in the next element.</li><li>The jpaProperties allows to pass raw properties to the JPA implementation, bypassing the Spring ORM adapter.  In this case we pass parameter so that Hibernate will show us the SQL it's executing, the type of database we'll be connecting to, and finally instruct hibernate to recreate the schema every time the EntityManager is started.  In this case, the first two parameters could have been expressed inside the jpaVendorAdapter in a less verbose way.  However, the last parameter cannot be expressed inside jpaVendorAdapter.  The only parameter than can be expressed for "hibernate.hbm2ddl.auto" inside the jpaVendorAdapter is  "update". By setting "hibernate.hbm2ddl.auto" to "create-drop" we get access to a hibernate specific functionality that allows us to execute a file (called "import.sql") after the database structure has been created.  You can find more information <a href="http://docs.jboss.org/hibernate/orm/4.1/manual/en-US/html_single/#configuration-optional">here</a>.</li><li>The transaction manager we are using is appropriate to the JPA infrastructure we're using.  By default this bean will be injected with an entity manager factory bean called "entityManagerFactory".  This can be overridden by passing a property with name  "entityManagerFactory".</li></ol>Looking at the import.sql file mentioned before will give us an idea of how the database looks, but we'll into more detail how it looks when we examine the entity class: <br /><p><b>src/main/resources/import.sql</b></p> <pre class="brush: sql">INSERT INTO PERSON (firstName,lastName) VALUES ('Joe','Doe') ;<br /></pre>Now let's look at the actual code, starting with the Person entity class.  An application will most likely have more than one entity class, but for this example we'll make do with only one.  If you need more, just add them to one of the packages that will be scanned.  <br /><p><b>src/main/java/test/model/Person.java</b></p> <pre class="brush: java">@Entity //1<br />public class Person {<br /><br />  @Id //2<br />  @GeneratedValue //3<br />  private Long id;<br />  private String firstName;<br />  private String lastName;<br />  private String email;<br /><br />  // Getters and setters removed for brevity.<br />}<br /></pre><ol><li>The @Entity annotation specifies that the class is an entity.  At the class level, other annotations can be applied, for example @Table, to specify a table.  Otherwise defaults will apply.  In this case the table name defaults to "Person" (the class name with the first letter capitalized.</li><li>The @Id annotation specifies that this field is the primary key of the table.</li></ol>A few notes when declaring entity classes: <br /><ul><li>By default, all fields are persisted, even if not annotated.  If you want to exclude a filed, add the @Transient annotation.</li><li>You can specify the column name (among other properties) using the @Column annotation.  If you omit this annotation, the default column name will be used (field name with capitalized first letter).</li><li>Annotations can be placed on the fields, or on the getters.  Placing them on the getters will signal the JPA implementations to use JavaBean property access instead of field access.  It is however recommended to not mix both in a single entity class.</li></ul>Now we'll look at the DAO (Data Access Object).  At this point it's fairly simple, and just implements a single method from an interface: <br /><p><b>src/main/java/test/dao/impl/PersonDAO.java</b></p> <pre class="brush: java">@Repository   //1<br />public class PersonDAO  implements IPersonDAO {<br /><br />    @PersistenceContext<br />    private EntityManager em; //2<br /><br />    @Override<br />    public List&lt;Person&gt; findAll() {<br />        Query query = em.createQuery("SELECT e FROM Person e"); //3<br />        return (List&lt;Person&gt;) query.getResultList();<br />    }<br /><br />}<br /></pre><ol><li>The @Repository annotation is a Spring stereotype, which is similar to @Component.  The only extra functionality it provides is SQL exception translation.</li><li>The EntityManager is injected thanks to the @PersistenceContext annotation.  This is the interface that we use to interact with the JPA system.</li><li>Our lonely method uses JPQL (Java Persistence Query Language) to query and return a list of all Persons.  This is executed through the EntityManager.</li></ol>The DAO is not called directly, but rather through service layer: <br /><p><b>src/main/java/test/service/impl/PersonService.java</b></p> <pre class="brush: java">@Service //1<br />@Transactional //2<br />public class PersonService implements IPersonService{<br /><br />    @Autowired //3<br />    private IPersonDAO personDAO;<br /><br />    @Override<br />    public List&lt;Person&gt; findAll() {<br />        return personDAO.findAll(); //4<br />    }<br /><br />}<br /></pre><ol><li>The @Service annotation is another Spring stereotype.  However, @Service does not provide any additional functionality by default.  You can later implement special handling based on this annotation.</li><li>The @Transactional annotation specifies that method calls on this class.  You can specify several parameters, but by default it will require transactions, reusing a current one or starting a new one.  This is good enough for a lot of usages, but can be tweaked if needed.</li><li>The DAO is injected with @Autowired.  Where possible we use interfaces.</li><li>The actual call to the DAO is fairly simple.  However, it's worth noting that if we called more than one method in the DAO, both calls will be run inside the same transaction.</li></ol>The web controller provides an "action" that users can invoke through their web browsers: <br /><p><b>src/main/java/test/controllers/TestController.java</b></p> <pre class="brush: java">@Controller //1<br />public class TestController {<br /><br />    @Autowired //2<br />    private IPersonService personService;<br /><br />    @RequestMapping("/view") //3<br />    public ModelAndView view() {<br />        ModelAndView ret=new ModelAndView("view"); //4<br />        List&lt;Person&gt; persons=personService.findAll();<br />        ret.addObject("persons",persons); //5<br />        return ret;<br />    }<br />}<br /></pre><ol><li>The @Controller annotation is yet another specialization of @Controller, used to specify that  the class is a web controller.  However, this needs to go together with one or more @RequestMapping annotations to actually become accessible.</li><li>The person service is autowired, just like we wired the DAO into the service in the previous file.</li><li>The @RequestMapping defines what url this controller will respond to.  In this case we're mapping to "/view.html".  The html extension comes from the mapping in the web.xml.  Further diferenciation can be done based on other elements of the request, such a method, agent, etc.  This annotation can be applied to a method, or to a type AND method.  If applied to a type, method level annotation are also required, and the paths declared on the method annotation will be appended to path defined in the type annotation.</li><li>The ModelAndView is one of the many return types that @RequestMapping annotated methods can return, and is one of the most useful ones.  It allows us to define the view, and well as the model (data) that will be rendered by the view.  In this case the constructor takes a view name.  This view name will be resolved to /WEB-INF/jsp/view.jsp by the InternalResourceViewResolver we defined in spring.xml.</li><li>The last step is to populate the model data, in this case a list of all persons fetched by our person service.  This list will be available in the view under the name "persons".</li></ol>The last part is the view, which is a regular JSP (Java Server Pages):  <br /><p><b>src/main/webapp/WEB-INF/jsp/view.jsp</b></p> <pre class="brush: php">&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;  &lt;%-- 1 --%&gt;<br />&lt;html&gt;<br />    &lt;body&gt;<br />        &lt;table border="1"&gt;<br />            &lt;tr&gt;<br />                &lt;th&gt;First Name&lt;/th&gt;<br />                &lt;th&gt;Last Name&lt;/th&gt;<br />            &lt;/tr&gt;<br />        <br />        <br />            &lt;c:forEach items="${persons}" var="person"&gt; &lt;%-- 2 --%&gt;<br />                &lt;tr&gt;<br />                    &lt;td&gt;${person.firstName}&lt;/td&gt;    &lt;%-- 3 --%&gt;<br />                    &lt;td&gt;${person.lastName}&lt;/td&gt;<br />                &lt;/tr&gt;<br />            &lt;/c:forEach&gt;<br />        &lt;/table&gt;<br />    &lt;/body&gt;<br />&lt;/html&gt;<br /></pre><ol><li>We declare the core tag library.  This provides basic control functionality, and is part of the Java Server Pages Standard Tag Library.</li><li>The core tag library allows an easy way to iterate over lists.  In this case we iterate over the "persons" object we returned from the controller method inside the ModelAndView object.</li><li>For each person we iterate over, we print the first and last name.</li></ol>We can then compile and run our small application with: <br /><pre>mvn tomcat:run<br /></pre>You can see the product of our work at http://localhost:8080/spring-hib-jpa/view.html : <a href="http://3.bp.blogspot.com/-zsLSlOVOsgg/UkXgeGW_EbI/AAAAAAAAALs/k1vLgdG7_Vo/s1600/sc1.png" imageanchor="1"><img border="0" src="http://3.bp.blogspot.com/-zsLSlOVOsgg/UkXgeGW_EbI/AAAAAAAAALs/k1vLgdG7_Vo/s400/sc1.png" /></a><br />This is a very basic example, but we've explored all of the plumbing required to build a database backed web application. In future posts we'll build on top of this application, and add feature such as, data entry, security, webservices, etc.  <a name="source_code"><p><b>Source Code</b></p></a>  <p>You can clone the code and play with it from github:</p>   <pre>git clone https://github.com/aolarte/tutorials.git<br /></pre>The finished code is contained in directory <strong>spring1_basics</strong>.  <p><b>Simple Spring and JPA with Hibernate tutorial series:</b></p><ul><li>Part 1: The basics </li><li><a href="http://codemethod.blogspot.com/2013/10/simple-spring-and-jpa-with-hibernate-part2.html">Part 2: Forms and persisting entities</a></li><li><a href="http://codemethod.blogspot.com/2013/10/simple-spring-and-jpa-with-hibernate-part3.html">Part 3: Simple security</a></li></ul>