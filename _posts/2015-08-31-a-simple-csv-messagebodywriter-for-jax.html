---
permalink: /:categories/:year/:month/:title.html
layout: post
title: A simple CSV MessageBodyWriter for JAX-RS using Jackson
date: '2015-08-31T14:19:00.000-07:00'
author: Andres Olarte
tags:
- jax-rs
- dropwizard
- JavaEE
- webservices
- rest
- tips
- java
modified_time: '2015-08-31T14:21:21.793-07:00'
blogger_id: tag:blogger.com,1999:blog-3306197464901287625.post-4237356648039431869
blogger_orig_url: http://www.javaprocess.com/2015/08/a-simple-csv-messagebodywriter-for-jax.html
---

This is a very simple MessageBodyWriter that will allow you to output a List of objects as CSV from a JAX-RS webservice. Such services can be useful with frameworks such as <a href="http://d3js.org/">D3.js</a>. Jackson provides MessageBodyWriters for several formats, but it does not provide an out of the box solution for CSV. It does however offer several useful &nbsp;classes to serialize objects into CSV. These are provided in the jackson-dataformat-csv artifact.<br />We can use those classes to create our own CSV MessageBodyWritter as shown below: <br /><pre class="brush: java">package csv;<br /><br /><br />import com.fasterxml.jackson.dataformat.csv.CsvMapper;<br />import com.fasterxml.jackson.dataformat.csv.CsvSchema;<br /><br />import javax.ws.rs.Produces;<br />import javax.ws.rs.WebApplicationException;<br />import javax.ws.rs.core.MediaType;<br />import javax.ws.rs.core.MultivaluedMap;<br />import javax.ws.rs.ext.MessageBodyWriter;<br />import javax.ws.rs.ext.Provider;<br />import java.io.IOException;<br />import java.io.OutputStream;<br />import java.lang.annotation.Annotation;<br />import java.lang.reflect.Type;<br />import java.util.List;<br /><br />@Provider<br />@Produces("text/csv")<br />public class CSVMessageBodyWritter implements MessageBodyWriter<list> {<br /><br />    @Override<br />    public boolean isWriteable(Class type, Type genericType, Annotation[] annotations, MediaType mediaType) {<br />        boolean ret=List.class.isAssignableFrom(type);<br />        return ret;<br />    }<br /><br />    @Override<br />    public long getSize(List data, Class aClass, Type type, Annotation[] annotations, MediaType mediaType) {<br />        return 0;<br />    }<br /><br />    @Override<br />    public void writeTo(List data, Class aClass, Type type, Annotation[] annotations, MediaType mediaType, MultivaluedMap<string object=""> multivaluedMap, OutputStream outputStream) throws IOException, WebApplicationException {<br />        if (data!=null &amp;&amp; data.size()&gt;0) {<br />            CsvMapper mapper = new CsvMapper();<br />            Object o=data.get(0);<br />            CsvSchema schema = mapper.schemaFor(o.getClass()).withHeader();<br />            mapper.writer(schema).writeValue(outputStream,data);<br />        }<br /><br /><br />    }<br /><br />}<br /></pre> To use our MessageBodyWriter, it must be registered. This can achieved in several ways, depending on your JAX-RS implementation. Normally Jersey and other JAX-RS implementations are configured to scan packages and look for resources. In such cases classed marked with @Provider will be registered automatically. In other cases, the registration will have to be done manually. For example in Dropwizard, you have to manually register the Writer at startup: <pre class="brush: java"><br /> @Override<br />    public void run(MyConfiguration configuration,<br />                    Environment environment) {<br />      <br />        environment.jersey().register(new CSVMessageBodyWritter());<br />    }<br /></pre>Once registered, it becomes trivial to have a web service that outputs CSV. It's just a matter of annotating your webservice with the same media type as the MessageBodyWritter: @Produces("text/csv").    <pre class="brush: java"><br />import javax.ws.rs.GET;<br />import javax.ws.rs.Path;<br />import javax.ws.rs.Produces;<br />import java.util.List;<br /><br />@Path("/status")<br />public class StatusResource {<br />    @GET<br />    @Produces("text/csv")<br />    public List&lt;Data&gt getData() {<br />        List&lt;Data&gt; data= service.getStatus();<br />        return data;<br />    }<br />}<br /></pre> Our data class is just a normal POJO:  <pre class="brush: java"><br />public class Data {<br />    private String date;<br />    private Integer minimum;<br />    private Integer maximum;<br />    private Integer average;<br /><br />    public Data() {<br /><br />    }<br /><br />    //Getters and setters as needed<br />}<br /></pre> The output will look like this: <pre class="brush: text"><br />average,date,maximum,minimum<br />90,3/1856,125,0<br />60,2/1856,115,16<br />60,4/1856,115,16<br /><br /></pre>This is a very simple implementation, but should be a good starting point. It's worth nothing that CSV is inherently limited, and can't easily represent hierarchical object graphs. Therefore you might need flatten your data before exporting to CSV. If you need to ingest a CSV in a webservice, you can follow a similar approach to create a MessageBodyReader that will create an object from a CSV stream. 