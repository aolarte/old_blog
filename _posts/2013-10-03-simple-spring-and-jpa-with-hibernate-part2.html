---
permalink: /:categories/:year/:month/:title.html
layout: post
title: 'Simple Spring and JPA with Hibernate tutorial. Part 2: Forms and persisting
  entities'
date: '2013-10-03T06:08:00.000-07:00'
author: Andres Olarte
tags:
- spring-mvc
- jpa
- hibernate
- spring
- java
modified_time: '2013-10-09T12:31:33.380-07:00'
thumbnail: http://1.bp.blogspot.com/-mT0Y5fUrkVk/UlWt5a4r5zI/AAAAAAAAANY/IruFua5VMcI/s72-c/sc7.png
blogger_id: tag:blogger.com,1999:blog-3306197464901287625.post-7002266935069714503
blogger_orig_url: http://www.javaprocess.com/2013/10/simple-spring-and-jpa-with-hibernate-part2.html
---

Continuing from the very <a href="http://codemethod.blogspot.com/2013/09/simple-spring-and-jpa-with-hibernate.html">basic spring example we did last week</a>, we'll add some more features to demonstrate some more basic JPA and Spring functionality: <br /><ul><li>Spring forms</li><li>Spring model attributes</li><li>Persisting and merging entities in JPA</li></ul>At the end of the post you can see instructions on how to get the <a href="#source_code">source code</a>.  Since we're building up from the previous example, we'll only go over the parts that have changed:   We start by looking at the Person DAO, in which we added two methods, one to persist person objects, and another to query a person, based on the id.  The corresponding interfaces for the DAO and service classes have also been updated with the new methods. <br /><pre class="brush: java">@Repository<br />public class PersonDAO  implements IPersonDAO {<br /><br />    @PersistenceContext<br />    private EntityManager em;<br /><br />    @Override<br />    public List&lt;Person&gt; findAll() {<br />        Query query = em.createQuery("SELECT e FROM Person e");<br />        return (List&lt;Person&gt;) query.getResultList();<br />    }<br /><br />    public void persist(Person person) {        <br />        em.merge(person); //1<br />    }<br /><br />    public Person findById(Long id) {<br />        return em.find(Person.class,id); //2<br />    }<br />}<br /></pre><ol><li>The merge method persists the state of the object.  If the object doesn't exist (if it has no id, or an object with the passed in id does not exist in the database) a row in the database will be created.</li><li>The find methods allows to find a entity of a particular class, based on the id.  This could also be achieved using an JPQL query.</li></ol>In the person service class, we simply added two delegate methods to the DAO. <br /><pre class="brush: java">@Service<br />@Transactional<br />public class PersonService implements IPersonService{<br /><br />    @Autowired<br />    private IPersonDAO personDAO;<br /><br />    @Override<br />    public List&lt;Person&gt; findAll() {<br />        return personDAO.findAll();<br />    }<br /><br />    @Override<br />    public Person findById(Long id) {<br />        return personDAO.findById(id); <br />    }<br /><br />    @Override<br />    public void persist(Person person) {<br />        personDAO.persist(person); <br />    }<br />}<br /></pre>Now we look at the controller, in which we added several three methods that handle requests.  One to display the UI to edit an existing record, one to display the UI to enter a new record, and one we we post the modified or new entry. <br /><pre class="brush: java">@Controller<br />public class TestController {<br /><br />    @Autowired<br />    private IPersonService personService;<br /><br />    @RequestMapping(value="/view",method = RequestMethod.GET)<br />    public ModelAndView view() {<br />        ModelAndView ret=new ModelAndView("view");<br />        List&lt;Person&gt; persons=personService.findAll();<br />        ret.addObject("persons",persons);<br />        return ret;<br />    }<br /><br />    @RequestMapping(value="/view/{id}",method = RequestMethod.GET)  //1<br />    public ModelAndView viewById(@PathVariable Long id) { //2<br />        ModelAndView ret=new ModelAndView("person");<br />        Person person=personService.findById(id); //3<br />        ret.addObject("person",person);<br />        return ret;<br />    }<br /><br />    @RequestMapping(value="/new",method = RequestMethod.GET)<br />    public ModelAndViewnewPerson(Person person) { //4<br />        ModelAndView ret=new ModelAndView("person");<br />        ret.addObject("person",person);<br />        return ret;<br />    }<br /><br />    @RequestMapping(value="/post",method =  RequestMethod.POST)<br />    public ModelAndView post(Person person) { //5<br />        ModelAndView ret=new ModelAndView("view");<br />        personService.persist(person); //6<br />        List&lt;Person&gt; persons=personService.findAll();<br />        ret.addObject("persons",persons);<br />        return ret;<br /><br />    }<br /><br />}<br /></pre><ol><li>The first new method allows to view an edit a specific person, base on the person's id.  A new notation is introduced here, to pass variables from the URL.  In this case, variables surrounded by brackets (in this case {id}) are passed as variables annotated with @PathVariable.  We also specify that this method will only be invoked for GET requests.</li><li>By default, path variables are mapped based on name of the paramenter and the name in the url.  A different name can be specified by changing the annotation @PathVariable("locationId").</li><li>We utilize one of the new methods we created in the service classes to find the person given the id.  We then pass that person to the model.</li><li>The newPerson method declares a Person object in its signature.  This is a model attribute.  Since this attribute is not yet bound, and empty Person object will be passed.  We pass this object to view.</li><li>In the post method, we have a similar method signature with the Person object.  In this case we do expect the object to be bound, since it's coming from a form which we'll see a bit later.</li><li>We use the person service to persist the person object we received from the form, and then retrieve the list of all persons in the system.</li></ol>To expose the new functionality, we have to make a few changes to the jsp we we using to display the persons: <br /><pre class="brush: php">&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt; <br />&lt;html&gt;<br />    &lt;body&gt;<br />        &lt;table border="1"&gt;<br />            &lt;tr&gt;<br />                &lt;th&gt;First Name&lt;/th&gt;<br />                &lt;th&gt;Last Name&lt;/th&gt;<br />            &lt;/tr&gt;<br /><br /><br />            &lt;c:forEach items="${persons}" var="person"&gt;<br />                &lt;tr&gt;<br />                    &lt;c:url var="personUrl" value="view/${person.id}.html"/&gt;  &lt;%-- 2 --%&gt;<br />                    &lt;td&gt;<br />                        &lt;a href="${personUrl}"&gt;<br />                            ${person.firstName}<br />                        &lt;/a&gt;<br />                    &lt;/td&gt;<br />                    &lt;td&gt;<br />                        &lt;a href="${personUrl}"&gt;<br />                            ${person.lastName}<br />                        &lt;/a&gt;<br />                    &lt;/td&gt;<br />                &lt;/tr&gt;<br />            &lt;/c:forEach&gt;<br />        &lt;/table&gt;<br />        &lt;a href="new.html"&gt;Click here to add a new entry&lt;/a&gt;  &lt;%-- 3 --%&gt;<br />    &lt;/body&gt;<br />&lt;/html&gt;<br /></pre><ol><li>We use the url tag to put together a url that includes the person id, and we store it in a variable named personUrl.   Using the url tag is good practice since it takes into account the context of the application when creating urls.  We then add the proper tags to link from each person.</li><li>We add a simple link to a new page, that will enable us to create a new person record.</li></ol>We also add a new jsp that allows us to edit and create new persons. <br /><pre class="brush: php">&lt;%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %&gt;<br />&lt;%@ taglib uri="http://www.springframework.org/tags/form" prefix="form"%&gt;  &lt;%-- 1 --%&gt;<br />&lt;html&gt;<br />    &lt;body&gt;<br /><br />        &lt;c:url var="postUrl" value="/post.html"/&gt;  &lt;%-- 2 --%&gt;<br />        &lt;form:form method="POST" commandName="person" action="${postUrl}"&gt;  &lt;%-- 3 --%&gt;<br />            &lt;form:input path="firstName" /&gt;  &lt;%-- 4 --%&gt;<br />            &lt;br/&gt;<br />            &lt;form:input path="lastName" /&gt;<br />            &lt;br/&gt;<br />            &lt;form:input path="email" /&gt;<br />            &lt;br/&gt;<br />            &lt;form:hidden path="id" /&gt;  &lt;%-- 5 --%&gt;<br />            &lt;input type="submit" value="Submit"&gt;  &lt;%-- 6 --%&gt;<br />        &lt;/form:form&gt;<br />    &lt;/body&gt;<br />&lt;/html&gt;<br /></pre><ol><li>We add another tag library, in this case the Spring form library which enables us to work with model attributes (in this case the Person object).</li><li>We use the url tag to put together the url where we'll post our form. </li><li>The "form:form" tag will render as a normal form html tag, but it takes a lot of the work of setting it up, if used within the scope of Spring MVC.  Other than the standard "method" and "action" parameters, the tag takes a "commandName", which is the name of the model attribute that will be passed from the controller.  It defaults to "command", but for this example we're specifying "person" to make it more readable.</li><li>Tags such as "form:input" mimic standard HTML tags, but provide wiring to model attribute through the "path" attribute.  In this case the field will be wired to the data of the field "fistName" in the person object.</li><li>A hidden field ensures we send the id of the person object (in case we're editing an existing one).  This will ensure we update the current record, and not create a new one.</li><li>A plain submit HTML button is all that's needed to complete the form.</li></ol>We can then compile and run our small application with:<br /><br /><pre>mvn tomcat:run<br /></pre><br />You can open a browser and see the the application running at http://localhost:8080/spring-hib-jpa/view.html:<br />  <a href="http://1.bp.blogspot.com/-mT0Y5fUrkVk/UlWt5a4r5zI/AAAAAAAAANY/IruFua5VMcI/s1600/sc7.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" height="272" src="http://1.bp.blogspot.com/-mT0Y5fUrkVk/UlWt5a4r5zI/AAAAAAAAANY/IruFua5VMcI/s640/sc7.png" width="640" /></a>  <br />You can also add new people by clicking "Click here to add a new entry":<br /> <a href="http://2.bp.blogspot.com/-M6dplwvnLaw/UlWt5WziWZI/AAAAAAAAANQ/hJ0PxApsl4I/s1600/sc5.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" height="272" src="http://2.bp.blogspot.com/-M6dplwvnLaw/UlWt5WziWZI/AAAAAAAAANQ/hJ0PxApsl4I/s640/sc5.png" width="640" /></a>  And how they are persisted:<br /> <a href="http://3.bp.blogspot.com/-WiL3v0iMDVM/UlWt5W6cyJI/AAAAAAAAANM/iPNmm-0703o/s1600/sc6.png" imageanchor="1" style="clear: left; float: left; margin-bottom: 1em; margin-right: 1em;"><img border="0" height="272" src="http://3.bp.blogspot.com/-WiL3v0iMDVM/UlWt5W6cyJI/AAAAAAAAANM/iPNmm-0703o/s640/sc6.png" width="640" /></a> <br /> <a name="source_code"><p><b>Source Code</b></p></a>  You can clone the code and play with it from github:  <br /><pre>git clone https://github.com/aolarte/tutorials.git</pre>The finished code is contained in directory <strong>spring2_forms</strong>. If you want to start with the base code, use the directory <strong>spring1_basics</strong>.  <br /><br /><b>Simple Spring and JPA with Hibernate tutorial series:</b><br /><ul><li><a href="http://codemethod.blogspot.com/2013/09/simple-spring-and-jpa-with-hibernate.html">Part 1: The basics</a></li><li>Part 2: Forms and persisting entities </li><li><a href="http://codemethod.blogspot.com/2013/10/simple-spring-and-jpa-with-hibernate-part3.html">Part 3: Simple security</a></li></ul><br />